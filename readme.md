## git日志输出到文件
``` git
git reflog --pretty=format:"%ai,%an:%s" >log.txt
```

## 模型层的封装
 - 前提：我们要按照OOP的思想封装MVC框架，因为主流的的编程思想就是OOP（面向对象），那么我们的框架中，最小的单位就是类
 - 如何使用OOP封装模型层呢？
   一张表-------->看做是一个整体------>类
   表的操作（增删改查）------->看做是类的方法
 - 在模型里面要想操作数据库，需要使用我们之前封装过DAOPDO类实现，所以我们在模型中实例化DAOPDO类：
 - 将来不只是增加用户时需要使用PDO类，删除用户、修改用户、查询用户都需要使用DAOPDO这个类，所以我们就可以将公共的代码封装到构造方法中：
## 基础模型类
 - 上面的代码还有问题：将来项目会有很多模型类，每个模型类都需要使用DAOPDO类对数据库进行操作，所以我们就将公共的代码提取到一个基础类中，其他类再从这里继承 
 - 哪个模型类需要使用这个公共的代码，再从基础模型类中继承即可
##	工厂类实例化单例对象
 - 接下来我们要想调用模型的模仿，需要先实例化模型对象，之前说过：模型对象只需要实例化一个就够了，之前采用的是三私一公的方式，实例化一个单例对象，这样需要在每个模型类里面都得定义3个私有、1个公共的方法，这种写法比较繁琐
 - 接下来我们采用工厂模式去实例化一个单例对象，工厂模式在我们这里指的就是，传递模型类进来，我给你生产模型对象出去
 - 我们需要将数组定义为静态的变量，这样，在脚本周期内会将数组的值保存到内存中
 
 
## 控制器层的封装
 - 控制器层是根据功能模块划分的，为什么按照功能模型进行划分呢？
 - 如果按照功能模块进行划分，便于分工协作开发，一个员工负责一个功能，功能又是一个控制器类；
 - 所以这个员工只需要负责一个控制器即可
功能模块是在项目分析阶段就决定的；
 - 也就是说，这个项目包括哪些功能，在分析项目时就决定了。
 - 既然按照功能模块进行划分的，那么每个功能模块里面的操作（例如分类的管理：分类列表、添加分类、删除分类、修改分类）封装到控制器的方法中
 - 说明：控制器的方法后面加上Action后缀，目的是为了避免和模型类里面的方法名重复，方便记忆
 - 通常我们在控制器类里面发布命令：命令模型处理数据、命令视图显示数据
## 基础控制器类
 - 将来项目会有很多功能模块，每个功能模块又是一个控制器类，每个控制器中都需要使用smarty进行数据的分配，所以我们将smarty的初始化再次封装到一个基础的控制器类中，其他的控制器再继承
 - 所有的控制器类都需要继承该基础控制器类

## MVC目录划分原则
 - 将来使用mvc框架的时候，有一些代码是和具体项目的业务相关的；
 - 所以我们将这些代码封装到项目的目录里面，通常取名为application，
 - 该名称可以自己修改（jd、taobao）；
 - 除此之外，还有一些代码是公共的（Controller.class.php，Model.class.php等等）；
 - 这些代码不管做什么项目都可能会用到，我们就将其封装刀片框架目录里面；
 - 取名为framework
## 搭建MVC目录结构
 - 由于随着框架的不断完善，里面会出现很多有用的工具类；
 - 所以为了有效的管理，我们分目录存储
 - 像smarty这样别人提供，我们就封装到vendor目录，表示别人赞助的
 - 像Captcha、Page等等，我们自己写的，一些工具，我们就保存到tools目录
 - 像DAOPDO、I_DAO这些类、接口，和数据访问相关的，保存到dao目录
## 应用程序代码
 - 由于应用程序（项目），分为前台、后台；
 - 前台是用户浏览使用的；
 - 后台是管理员进行内容管理的；
 - 所以我们项目的目录结构也就划分为前台home、后台admin：
 - 由于前台、后台为了提高开发效率，也都会使用mvc进行代码的管理
## 入口文件
 - 入口文件又称之为分发控制器；
 - 就像公司的前台，根据访客的需求，将其引导到对应的办公室。
 - 在我们的框架里面，入口文件会根据用户的需求，引导到对应的文件
 - 那么我们需要在入口文件传递什么参数呢？也就是需要告诉前台哪些信息呢？
    - 去前台还是后台？admin?home
    - 去哪个控制器？controller?
    - 访问控制器的哪个方法？
    
## 自动加载机制
 - 项目中还有很多类需要require加载，这是一个很庞大的工作，而且很繁琐;
 - 所以我们使用自动加载机制完成这个工作
 - 当我们使用一个类，但是这个类不存在时，就会触发自动加载机制，自动加载机制提供了最后一次机会，可以把类加载过来
 - New 类，不存在
 - 类：：静态方法时，类不存在
 - 类  extends  类2，类2不存在
 - 类 implements 接口，接口不存在
## 结合命名空间
 - 入口文件就不用加命名空间了。因为入口文件用来加载其他类，不定义类
 - 每个类的命名空间包含当前类所在的路径
 例如：框架的成员，命名空间定义为：framework\core，项目的类命名空间就不要携带application了，因为application是项目的名称，后期可能会变化，所以项目的类的命名空间：admin\controller或home\controller等
 - 第三方的类，我们不用增加命名空间，我们做一个特例处理（手动require）
## 完成自动加载
 - 就是根据提示的需要的类名，解析出他所在的路径
## 封装入口文件
 - 入口文件有什么好封装的呢？
 - 因为我们采用的OOP（面向对象的思想）封装的框架，框架里面的代码都应该是类，然而现在的入口文件index.php是完全面向过程的写法，所以我们要将其封装到类中

    



 
